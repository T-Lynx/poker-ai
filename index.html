<!doctype html>
<html lang="vi">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>5-Card Poker (Offline) ‚Äî Demo</title>
        <style>
            :root {
                --bg: #0b1220;
                --card: #fff;
                --accent: #4f8ef7;
                --muted: #c8d1e7;
            }
            body {
                font-family:
                    system-ui,
                    Segoe UI,
                    Helvetica,
                    Arial;
                color: var(--muted);
                background: linear-gradient(180deg, #071026, #071a2e);
                padding: 16px;
            }
            h1 {
                color: var(--card);
                margin: 0 0 8px;
            }
            .top {
                display: flex;
                gap: 12px;
                align-items: center;
                margin-bottom: 12px;
                flex-wrap: wrap;
            }
            .controls {
                display: flex;
                gap: 8px;
                align-items: center;
            }
            button {
                background: var(--accent);
                border: none;
                color: white;
                padding: 8px 12px;
                border-radius: 8px;
                cursor: pointer;
            }
            button.secondary {
                background: transparent;
                border: 1px solid rgba(255, 255, 255, 0.08);
            }
            .table {
                display: grid;
                grid-template-columns: 1fr 2fr 1fr;
                gap: 12px;
                align-items: start;
            }
            .panel {
                background: rgba(255, 255, 255, 0.03);
                padding: 12px;
                border-radius: 10px;
                min-height: 120px;
            }
            .players {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }
            .player {
                background: rgba(255, 255, 255, 0.02);
                padding: 8px;
                border-radius: 8px;
                min-width: 180px;
            }
            .hand {
                display: flex;
                gap: 6px;
                margin-top: 8px;
                flex-wrap: wrap;
            }
            .card {
                width: 56px;
                height: 80px;
                border-radius: 6px;
                background: white;
                color: black;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: 700;
            }
            .card.hidden {
                background: linear-gradient(135deg, #334155, #0f1724);
                color: transparent;
            }
            .actions {
                margin-top: 8px;
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }
            .status {
                font-size: 14px;
                color: var(--muted);
                margin-top: 8px;
            }
            .pot {
                font-weight: 700;
                color: var(--card);
            }
            .center-area {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 8px;
            }
            .table-cards {
                display: flex;
                gap: 8px;
                align-items: center;
            }
            .chip {
                background: #ffd166;
                color: #2b2b2b;
                padding: 4px 8px;
                border-radius: 999px;
                font-weight: 700;
            }
            .selected {
                outline: 3px solid rgba(79, 142, 247, 0.2);
            }
            input[type="number"] {
                width: 80px;
                padding: 6px;
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.08);
                background: transparent;
                color: var(--muted);
            }
            footer {
                margin-top: 12px;
                color: rgba(255, 255, 255, 0.5);
                font-size: 13px;
            }
        </style>
    </head>
    <body>
        <h1>5-Card Poker ‚Äî Offline (5-card draw)</h1>
        <div class="top">
            <div class="controls">
                <label
                    >Ch·∫ø ƒë·ªô:
                    <select id="mode">
                        <option value="solo">Solo (1 ng∆∞·ªùi vs bots)</option>
                        <option value="local">Local (pass-and-play)</option>
                    </select>
                </label>
                <label
                    >Ng∆∞·ªùi ch∆°i:
                    <select id="numPlayers">
                        <option>2</option>
                        <option>3</option>
                        <option selected>4</option>
                    </select>
                </label>
                <button id="newGame">B·∫Øt ƒë·∫ßu v√°n m·ªõi</button>
                <button id="deal" class="secondary">Chia b√†i</button>
            </div>
            <div style="margin-left: auto">
                <span class="chip">Pot: <span id="pot">0</span></span>
            </div>
        </div>

        <div class="table">
            <div class="panel">
                <div><strong>Ng∆∞·ªùi ch∆°i</strong></div>
                <div id="players" class="players"></div>
            </div>

            <div class="panel center-area">
                <div><strong>Trung t√¢m</strong></div>
                <div class="status">
                    Tr·∫°ng th√°i: <span id="status">Ch∆∞a b·∫Øt ƒë·∫ßu</span>
                </div>
                <div class="table-cards" id="tableCards"></div>
                <div class="actions" id="globalActions"></div>
            </div>

            <div class="panel">
                <div><strong>H√†nh ƒë·ªông</strong></div>
                <div id="actionsArea" class="actions"></div>
                <div class="status" id="infoArea"></div>
            </div>
        </div>

        <footer>
            Demo: 5-card draw ‚Äî offline ‚Äî simple AI. Mu·ªën t√≠nh nƒÉng m·ªü r·ªông
            (chat, animation, betting n√¢ng cao...), b√°o m√¨nh nh√©.
        </footer>

        <script>
            /* ====== GAME CORE ====== */
            const SUITS = ["‚ô†", "‚ô•", "‚ô¶", "‚ô£"];
            const RANKS = [
                { r: "2", v: 2 },
                { r: "3", v: 3 },
                { r: "4", v: 4 },
                { r: "5", v: 5 },
                { r: "6", v: 6 },
                { r: "7", v: 7 },
                { r: "8", v: 8 },
                { r: "9", v: 9 },
                { r: "10", v: 10 },
                { r: "J", v: 11 },
                { r: "Q", v: 12 },
                { r: "K", v: 13 },
                { r: "A", v: 14 },
            ];

            function createDeck() {
                const d = [];
                for (const s of SUITS)
                    for (const rk of RANKS)
                        d.push({ suit: s, rank: rk.r, value: rk.v });
                return d;
            }
            function shuffle(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                return deck;
            }

            /* ====== Hand evaluator (5-card poker) ====== */
            function evaluateHand(cards) {
                // cards: array of {suit,rank,value}
                const vals = cards.map((c) => c.value).sort((a, b) => a - b);
                const suits = cards.map((c) => c.suit);
                const counts = {};
                for (const v of vals) counts[v] = (counts[v] || 0) + 1;
                // sort values for tiebreakers descending unique
                const freqPairs = Object.entries(counts).map(([v, c]) => ({
                    v: +v,
                    c,
                }));
                freqPairs.sort((a, b) => b.c - a.c || b.v - a.v);

                const isFlush = suits.every((s) => s === suits[0]);
                // detect straight (including wheel A-2-3-4-5)
                let isStraight = false;
                const uniqVals = [...new Set(vals)];
                if (uniqVals.length === 5) {
                    const max = uniqVals[4],
                        min = uniqVals[0];
                    if (max - min === 4) isStraight = true;
                    else {
                        // check wheel
                        if (
                            JSON.stringify(uniqVals) ===
                            JSON.stringify([2, 3, 4, 5, 14])
                        )
                            isStraight = true;
                    }
                }

                // ranks precedence: 8 SF,7 Four,6 Full,5 Flush,4 Straight,3 Trips,2 TwoPair,1 OnePair,0 HighCard
                if (isStraight && isFlush)
                    return {
                        rank: 8,
                        tiebreak: [
                            Math.max(...vals) === 14 && vals.includes(2)
                                ? 5
                                : Math.max(...vals),
                        ],
                        name: "Straight Flush",
                    };
                if (freqPairs[0].c === 4)
                    return {
                        rank: 7,
                        tiebreak: [freqPairs[0].v, freqPairs[1].v],
                        name: "Four of a Kind",
                    };
                if (
                    freqPairs[0].c === 3 &&
                    freqPairs[1] &&
                    freqPairs[1].c === 2
                )
                    return {
                        rank: 6,
                        tiebreak: [freqPairs[0].v, freqPairs[1].v],
                        name: "Full House",
                    };
                if (isFlush)
                    return {
                        rank: 5,
                        tiebreak: vals.slice().sort((a, b) => b - a),
                        name: "Flush",
                    };
                if (isStraight)
                    return {
                        rank: 4,
                        tiebreak: [
                            Math.max(...vals) === 14 && vals.includes(2)
                                ? 5
                                : Math.max(...vals),
                        ],
                        name: "Straight",
                    };
                if (freqPairs[0].c === 3) {
                    const kickers = freqPairs
                        .slice(1)
                        .map((x) => x.v)
                        .sort((a, b) => b - a);
                    return {
                        rank: 3,
                        tiebreak: [freqPairs[0].v, ...kickers],
                        name: "Three of a Kind",
                    };
                }
                if (
                    freqPairs[0].c === 2 &&
                    freqPairs[1] &&
                    freqPairs[1].c === 2
                ) {
                    const pairHigh = Math.max(freqPairs[0].v, freqPairs[1].v);
                    const pairLow = Math.min(freqPairs[0].v, freqPairs[1].v);
                    const kicker = freqPairs.slice(2).map((x) => x.v)[0];
                    return {
                        rank: 2,
                        tiebreak: [pairHigh, pairLow, kicker],
                        name: "Two Pair",
                    };
                }
                if (freqPairs[0].c === 2) {
                    const kickers = freqPairs
                        .slice(1)
                        .map((x) => x.v)
                        .sort((a, b) => b - a);
                    return {
                        rank: 1,
                        tiebreak: [freqPairs[0].v, ...kickers],
                        name: "One Pair",
                    };
                }
                // high card
                return {
                    rank: 0,
                    tiebreak: vals.slice().sort((a, b) => b - a),
                    name: "High Card",
                };
            }

            function compareHands(hA, hB) {
                if (hA.rank !== hB.rank) return hA.rank > hB.rank ? 1 : -1;
                for (
                    let i = 0;
                    i < Math.max(hA.tiebreak.length, hB.tiebreak.length);
                    i++
                ) {
                    const a = hA.tiebreak[i] || 0,
                        b = hB.tiebreak[i] || 0;
                    if (a !== b) return a > b ? 1 : -1;
                }
                return 0;
            }

            /* ====== GAME STATE ====== */
            let G = {
                deck: [],
                players: [], // {id,name,isBot,hand:[],chips,active (not folded),betThisRound}
                pot: 0,
                currentPlayerIdx: 0,
                dealerIdx: 0,
                stage: "idle", // 'pre', 'draw', 'post', 'showdown'
                minBet: 10,
                currentBet: 0,
                numPlayers: 4,
            };

            const ui = {
                playersEl: document.getElementById("players"),
                status: document.getElementById("status"),
                pot: document.getElementById("pot"),
                actionsArea: document.getElementById("actionsArea"),
                infoArea: document.getElementById("infoArea"),
                dealBtn: document.getElementById("deal"),
                newGameBtn: document.getElementById("newGame"),
                modeSel: document.getElementById("mode"),
                numPlayersSel: document.getElementById("numPlayers"),
            };

            function resetGame() {
                G.deck = shuffle(createDeck());
                G.pot = 0;
                G.players = [];
                G.currentBet = 0;
                G.stage = "idle";
                G.dealerIdx = 0;
                ui.infoArea.textContent = "";
                ui.status.textContent = "Ch∆∞a b·∫Øt ƒë·∫ßu";
                ui.pot.textContent = G.pot;
            }

            function startNewRound() {
                G.deck = shuffle(createDeck());
                for (const p of G.players) {
                    p.hand = [];
                    p.active = p.chips > 0;
                    p.betThisRound = 0;
                    p.folded = false;
                }
                G.pot = 0;
                G.currentBet = G.minBet;
                G.stage = "pre";
                // deal 5 cards each
                for (let i = 0; i < 5; i++) {
                    for (let pi = 0; pi < G.players.length; pi++) {
                        if (G.players[pi].chips > 0) {
                            G.players[pi].hand.push(G.deck.pop());
                        }
                    }
                }
                // set current player to left of dealer
                G.currentPlayerIdx = (G.dealerIdx + 1) % G.players.length;
                ui.status.textContent = "V√≤ng c∆∞·ª£c 1 (pre-draw)";
                ui.pot.textContent = G.pot;
                render();
                proceedTurn();
            }

            function initPlayers(num, mode) {
                G.players = [];
                for (let i = 0; i < num; i++) {
                    const isBot =
                        (mode === "solo" && i > 0) ||
                        (mode === "local" ? false : i > 0);
                    G.players.push({
                        id: i,
                        name: isBot ? `Bot ${i}` : `Ng∆∞·ªùi ${i + 1}`,
                        isBot,
                        hand: [],
                        chips: 500,
                        active: true,
                        folded: false,
                        betThisRound: 0,
                    });
                }
            }

            /* ====== UI RENDER ====== */
            function render() {
                ui.playersEl.innerHTML = "";
                G.players.forEach((p, idx) => {
                    const div = document.createElement("div");
                    div.className = "player";
                    if (idx === G.currentPlayerIdx)
                        div.style.boxShadow = "0 0 0 2px rgba(79,142,247,0.15)";
                    div.innerHTML = `<div><strong>${p.name}${p.isBot ? " ü§ñ" : ""}</strong> ${p.folded ? '<span style="color:#f77">[Folded]</span>' : ""}</div>
      <div>Chips: <span class="chip">${p.chips}</span></div>
      <div>Tay: <span style="color:var(--muted)">${p.hand.length ? "(" + p.hand.map((c) => c.rank + c.suit).join(" ") + ")" : "(r·ªóng)"}</span></div>
      <div class="hand" id="hand-${idx}"></div>
    `;
                    ui.playersEl.appendChild(div);
                    const handEl = div.querySelector(`#hand-${idx}`);
                    p.hand.forEach((c, i) => {
                        const cdiv = document.createElement("div");
                        cdiv.className =
                            "card" +
                            (!p.isBot ||
                            G.stage !== "pre" ||
                            idx === getHumanIndex()
                                ? ""
                                : " hidden");
                        cdiv.textContent = c.rank + c.suit;
                        if (!p.isBot || idx === getHumanIndex()) {
                            // if human, allow select card for draw
                            if (idx === getHumanIndex()) {
                                cdiv.addEventListener("click", () => {
                                    cdiv.classList.toggle("selected");
                                    c.selected =
                                        !!cdiv.classList.contains("selected");
                                });
                            }
                        }
                        handEl.appendChild(cdiv);
                    });
                });
                ui.pot.textContent = G.pot;
                ui.status.textContent =
                    {
                        idle: "Ch∆∞a b·∫Øt ƒë·∫ßu",
                        pre: "V√≤ng c∆∞·ª£c 1 (pre-draw)",
                        draw: "V√≤ng r√∫t b√†i",
                        post: "V√≤ng c∆∞·ª£c 2 (post-draw)",
                        showdown: "Showdown",
                    }[G.stage] || G.stage;
            }

            /* ====== Turn logic ====== */
            function getHumanIndex() {
                // find first non-bot
                return G.players.findIndex((p) => !p.isBot);
            }

            function proceedTurn() {
                // Skip folded or busted players
                if (G.stage === "pre" || G.stage === "post") {
                    // find next active player who hasn't folded and has chips
                    let loops = 0;
                    while (
                        G.players[G.currentPlayerIdx].folded ||
                        G.players[G.currentPlayerIdx].chips <= 0
                    ) {
                        G.currentPlayerIdx =
                            (G.currentPlayerIdx + 1) % G.players.length;
                        if (++loops > 20) break;
                    }
                    const p = G.players[G.currentPlayerIdx];
                    if (p.isBot) {
                        setTimeout(() => botAct(p), 600);
                        return;
                    } else {
                        // show actions for human
                        showActionsForHuman(p);
                    }
                } else if (G.stage === "draw") {
                    // iterate draw per player
                    handleDrawPhase();
                }
            }

            function showActionsForHuman(p) {
                ui.actionsArea.innerHTML = "";
                const callAmt = Math.max(0, G.currentBet - p.betThisRound);
                // Check
                const btnCheck = document.createElement("button");
                btnCheck.textContent =
                    callAmt === 0 ? "Check" : "Call " + callAmt;
                btnCheck.onclick = () => {
                    if (callAmt > 0) {
                        // call
                        const pay = Math.min(callAmt, p.chips);
                        p.chips -= pay;
                        p.betThisRound += pay;
                        G.pot += pay;
                    }
                    // move to next
                    G.currentPlayerIdx =
                        (G.currentPlayerIdx + 1) % G.players.length;
                    ui.actionsArea.innerHTML = "";
                    render();
                    // check if pre round finished
                    if (isBettingRoundComplete()) {
                        advanceStageAfterBet();
                    } else proceedTurn();
                };
                ui.actionsArea.appendChild(btnCheck);

                const btnFold = document.createElement("button");
                btnFold.className = "secondary";
                btnFold.textContent = "Fold";
                btnFold.onclick = () => {
                    p.folded = true;
                    G.currentPlayerIdx =
                        (G.currentPlayerIdx + 1) % G.players.length;
                    ui.actionsArea.innerHTML = "";
                    render();
                    if (isBettingRoundComplete()) advanceStageAfterBet();
                    else proceedTurn();
                };
                ui.actionsArea.appendChild(btnFold);

                // Raise
                const btnRaise = document.createElement("button");
                btnRaise.textContent = "Raise";
                btnRaise.onclick = () => {
                    const raiseAmt = G.minBet;
                    const totalToPut = Math.min(p.chips, callAmt + raiseAmt);
                    p.chips -= totalToPut;
                    p.betThisRound += totalToPut;
                    G.currentBet = p.betThisRound;
                    G.pot += totalToPut;
                    G.currentPlayerIdx =
                        (G.currentPlayerIdx + 1) % G.players.length;
                    ui.actionsArea.innerHTML = "";
                    render();
                    if (isBettingRoundComplete()) advanceStageAfterBet();
                    else proceedTurn();
                };
                ui.actionsArea.appendChild(btnRaise);

                ui.infoArea.textContent = `C·∫ßn call: ${callAmt} ‚Äî Pot: ${G.pot}`;
            }

            function botAct(p) {
                // Very simple bot: evaluate current hand strength; decide to call/raise/fold
                const h = evaluateHand(p.hand);
                const callAmt = Math.max(0, G.currentBet - p.betThisRound);
                // simple logic: if strong (pair+), call or raise. if weak, sometimes fold.
                let rnd = Math.random();
                if (h.rank >= 2) {
                    // two pair or better -> aggressive
                    if (rnd < 0.6) {
                        // raise
                        const raiseAmt = Math.min(p.chips, callAmt + G.minBet);
                        p.chips -= raiseAmt;
                        p.betThisRound += raiseAmt;
                        G.currentBet = Math.max(G.currentBet, p.betThisRound);
                        G.pot += raiseAmt;
                    } else {
                        // call
                        const pay = Math.min(callAmt, p.chips);
                        p.chips -= pay;
                        p.betThisRound += pay;
                        G.pot += pay;
                    }
                } else {
                    if (callAmt === 0) {
                        // check
                        // do nothing
                    } else {
                        // weak hand: fold with some probability
                        if (rnd < 0.5) {
                            p.folded = true;
                        } else {
                            const pay = Math.min(callAmt, p.chips);
                            p.chips -= pay;
                            p.betThisRound += pay;
                            G.pot += pay;
                        }
                    }
                }
                // advance player
                G.currentPlayerIdx =
                    (G.currentPlayerIdx + 1) % G.players.length;
                render();
                if (isBettingRoundComplete()) advanceStageAfterBet();
                else proceedTurn();
            }

            function isBettingRoundComplete() {
                // If all active players have betThisRound equal to currentBet or are folded or bust
                for (const p of G.players) {
                    if (p.folded || p.chips <= 0) continue;
                    if (p.betThisRound !== G.currentBet) return false;
                }
                return true;
            }

            function advanceStageAfterBet() {
                // reset players' betThisRound to 0 for next round; move stage
                for (const p of G.players) p.betThisRound = 0;
                if (G.stage === "pre") {
                    G.stage = "draw";
                    ui.status.textContent = "V√≤ng r√∫t b√†i";
                    // start draw sequence from left of dealer
                    G.currentPlayerIdx = (G.dealerIdx + 1) % G.players.length;
                    render();
                    proceedTurn();
                } else if (G.stage === "post") {
                    G.stage = "showdown";
                    ui.status.textContent = "Showdown";
                    render();
                    doShowdown();
                }
            }

            function handleDrawPhase() {
                // For draw phase: iterate players, let them select up to 3 to replace
                const p = G.players[G.currentPlayerIdx];
                if (p.folded || p.chips <= 0) {
                    G.currentPlayerIdx =
                        (G.currentPlayerIdx + 1) % G.players.length;
                    // check if all done
                    if (
                        G.currentPlayerIdx ===
                        (G.dealerIdx + 1) % G.players.length
                    ) {
                        // done draws -> go to post-draw betting
                        G.stage = "post";
                        G.currentBet = G.minBet;
                        G.currentPlayerIdx =
                            (G.dealerIdx + 1) % G.players.length;
                        ui.status.textContent = "V√≤ng c∆∞·ª£c 2 (post-draw)";
                        render();
                        proceedTurn();
                        return;
                    } else {
                        handleDrawPhase();
                        return;
                    }
                }
                if (p.isBot) {
                    // simple bot draw strategy: keep pairs or better, discard others up to 3
                    const counts = {};
                    p.hand.forEach(
                        (c) => (counts[c.value] = (counts[c.value] || 0) + 1),
                    );
                    const keepVals = Object.entries(counts)
                        .filter(([v, c]) => c >= 2)
                        .map((x) => +x[0]);
                    let toReplace = [];
                    for (const c of p.hand) {
                        if (keepVals.includes(c.value)) continue;
                        toReplace.push(c);
                    }
                    // limit to 3
                    toReplace = toReplace.slice(0, 3);
                    for (const r of toReplace) {
                        // replace card r
                        const idx = p.hand.indexOf(r);
                        if (idx >= 0 && G.deck.length > 0)
                            p.hand[idx] = G.deck.pop();
                    }
                    // next player
                    G.currentPlayerIdx =
                        (G.currentPlayerIdx + 1) % G.players.length;
                    // check completed
                    if (
                        G.currentPlayerIdx ===
                        (G.dealerIdx + 1) % G.players.length
                    ) {
                        // finished
                        G.stage = "post";
                        G.currentBet = G.minBet;
                        G.currentPlayerIdx =
                            (G.dealerIdx + 1) % G.players.length;
                        ui.status.textContent = "V√≤ng c∆∞·ª£c 2 (post-draw)";
                        render();
                        proceedTurn();
                        return;
                    } else {
                        handleDrawPhase();
                        render();
                        return;
                    }
                } else {
                    // human draw: allow selecting cards and pressing "Draw Selected"
                    ui.actionsArea.innerHTML = "";
                    const drawBtn = document.createElement("button");
                    drawBtn.textContent = "R√∫t l√° ƒë√£ ch·ªçn (t·ªëi ƒëa 3)";
                    drawBtn.onclick = () => {
                        // replace selected card(s)
                        const sel = p.hand.filter((c) => c.selected);
                        if (sel.length > 3) {
                            ui.infoArea.textContent =
                                "Kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 3 l√°";
                            return;
                        }
                        for (const r of sel) {
                            const idx = p.hand.indexOf(r);
                            if (idx >= 0 && G.deck.length > 0)
                                p.hand[idx] = G.deck.pop();
                        }
                        // clear selections
                        p.hand.forEach((c) => {
                            delete c.selected;
                        });
                        // next player
                        G.currentPlayerIdx =
                            (G.currentPlayerIdx + 1) % G.players.length;
                        ui.actionsArea.innerHTML = "";
                        render();
                        // check if finished draws
                        if (
                            G.currentPlayerIdx ===
                            (G.dealerIdx + 1) % G.players.length
                        ) {
                            G.stage = "post";
                            G.currentBet = G.minBet;
                            G.currentPlayerIdx =
                                (G.dealerIdx + 1) % G.players.length;
                            ui.status.textContent = "V√≤ng c∆∞·ª£c 2 (post-draw)";
                            render();
                            proceedTurn();
                            return;
                        } else handleDrawPhase();
                    };
                    ui.actionsArea.appendChild(drawBtn);
                    const skipBtn = document.createElement("button");
                    skipBtn.className = "secondary";
                    skipBtn.textContent = "Kh√¥ng r√∫t";
                    skipBtn.onclick = () => {
                        // clear selected and move on
                        p.hand.forEach((c) => {
                            delete c.selected;
                        });
                        G.currentPlayerIdx =
                            (G.currentPlayerIdx + 1) % G.players.length;
                        ui.actionsArea.innerHTML = "";
                        render();
                        if (
                            G.currentPlayerIdx ===
                            (G.dealerIdx + 1) % G.players.length
                        ) {
                            G.stage = "post";
                            G.currentBet = G.minBet;
                            G.currentPlayerIdx =
                                (G.dealerIdx + 1) % G.players.length;
                            ui.status.textContent = "V√≤ng c∆∞·ª£c 2 (post-draw)";
                            render();
                            proceedTurn();
                            return;
                        } else handleDrawPhase();
                    };
                    ui.actionsArea.appendChild(skipBtn);
                    ui.infoArea.textContent =
                        'Ch·ªçn t·ªëi ƒëa 3 l√° (click l√° ƒë·ªÉ ch·ªçn), sau ƒë√≥ nh·∫•n "R√∫t"';
                    render();
                }
            }

            function doShowdown() {
                // find not-folded players
                const contenders = G.players.filter(
                    (p) => !p.folded && p.hand.length === 5,
                );
                if (contenders.length === 0) {
                    ui.infoArea.textContent =
                        "Kh√¥ng c√≤n ng∆∞·ªùi ch∆°i: pot gi·ªØ l·∫°i (edge case).";
                    return;
                }
                // evaluate each
                const evals = contenders.map((p) => ({
                    p,
                    eval: evaluateHand(p.hand),
                }));
                // find winner(s)
                let best = evals[0];
                for (let i = 1; i < evals.length; i++) {
                    const cmp = compareHands(evals[i].eval, best.eval);
                    if (cmp > 0) best = evals[i];
                    else if (cmp === 0) {
                        // tie: keep both winners for split pot
                        if (!best.tied) best.tied = [best];
                        if (!best.tied.includes(evals[i])) {
                            if (!Array.isArray(best.tied)) best.tied = [best];
                            best.tied.push(evals[i]);
                        }
                    }
                }
                // collect winners
                let winners = [];
                if (best.tied && best.tied.length) {
                    winners = best.tied.map((x) => x.p);
                } else {
                    winners = [best.p];
                }
                // share pot equally
                const share = Math.floor(G.pot / winners.length);
                winners.forEach((w) => (w.chips += share));
                ui.infoArea.textContent = `K·∫øt qu·∫£: ${winners.map((w) => w.name).join(", ")} th·∫Øng (${evaluateHand(winners[0].hand).name}). M·ªói ng∆∞·ªùi nh·∫≠n ${share}.`;
                G.pot = 0;
                ui.pot.textContent = "0";
                render();
                // next: prepare next round (dealer move)
                G.dealerIdx = (G.dealerIdx + 1) % G.players.length;
                G.stage = "idle";
            }

            /* ====== Buttons ====== */
            ui.newGameBtn.onclick = () => {
                const mode = ui.modeSel.value;
                const num = parseInt(ui.numPlayersSel.value);
                G.numPlayers = num;
                resetGame();
                initPlayers(num, mode);
                ui.infoArea.textContent =
                    'Game created. Nh·∫•n "Chia b√†i" ƒë·ªÉ b·∫Øt ƒë·∫ßu v√°n.';
                render();
            };
            ui.dealBtn.onclick = () => {
                if (G.players.length === 0) {
                    ui.infoArea.textContent = 'Nh·∫•n "B·∫Øt ƒë·∫ßu v√°n m·ªõi" tr∆∞·ªõc.';
                    return;
                }
                startNewRound();
            };

            /* ====== init demo ====== */
            resetGame();
            initPlayers(4, "solo");
            render();
            ui.infoArea.textContent =
                'Ch·ªçn s·ªë ng∆∞·ªùi v√† nh·∫•n "B·∫Øt ƒë·∫ßu v√°n m·ªõi" r·ªìi "Chia b√†i".';
        </script>
    </body>
</html>
