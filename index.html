<!doctype html>
<html lang="vi">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>5-Card Poker (Offline) ‚Äî Demo</title>
        <style>
            :root {
                --bg: #0b1220;
                --card: #fff;
                --accent: #4f8ef7;
                --muted: #c8d1e7;
                --success: #10b981;
                --danger: #ef4444;
                --warning: #f59e0b;
            }
            body {
                font-family:
                    system-ui,
                    Segoe UI,
                    Helvetica,
                    Arial;
                color: var(--muted);
                background: linear-gradient(180deg, #071026, #071a2e);
                padding: 16px;
                min-height: 100vh;
            }
            h1 {
                color: var(--card);
                margin: 0 0 8px;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            }
            .top {
                display: flex;
                gap: 12px;
                align-items: center;
                margin-bottom: 12px;
                flex-wrap: wrap;
                background: rgba(255, 255, 255, 0.05);
                padding: 12px;
                border-radius: 12px;
                backdrop-filter: blur(10px);
            }
            .controls {
                display: flex;
                gap: 8px;
                align-items: center;
                flex-wrap: wrap;
            }
            button {
                background: var(--accent);
                border: none;
                color: white;
                padding: 10px 16px;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 500;
                transition: all 0.2s ease;
                box-shadow: 0 2px 8px rgba(79, 142, 247, 0.3);
            }
            button:hover {
                background: #3b7ce0;
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(79, 142, 247, 0.4);
            }
            button:active {
                transform: translateY(0);
            }
            button.secondary {
                background: transparent;
                border: 1px solid rgba(255, 255, 255, 0.2);
                box-shadow: none;
            }
            button.secondary:hover {
                background: rgba(255, 255, 255, 0.1);
                border-color: rgba(255, 255, 255, 0.3);
            }
            select,
            input {
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: var(--muted);
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 14px;
            }
            select:focus,
            input:focus {
                outline: none;
                border-color: var(--accent);
                box-shadow: 0 0 0 2px rgba(79, 142, 247, 0.2);
            }
            .table {
                display: grid;
                grid-template-columns: 1fr 2fr 1fr;
                gap: 16px;
                align-items: start;
            }
            @media (max-width: 768px) {
                .table {
                    grid-template-columns: 1fr;
                    gap: 12px;
                }
            }
            .panel {
                background: rgba(255, 255, 255, 0.05);
                padding: 16px;
                border-radius: 12px;
                min-height: 120px;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            .panel-title {
                font-weight: 600;
                color: var(--card);
                margin-bottom: 12px;
                font-size: 16px;
            }
            .players {
                display: flex;
                gap: 12px;
                flex-wrap: wrap;
            }
            .player {
                background: rgba(255, 255, 255, 0.05);
                padding: 12px;
                border-radius: 10px;
                min-width: 200px;
                border: 2px solid transparent;
                transition: all 0.3s ease;
            }
            .player.active {
                border-color: var(--accent);
                box-shadow: 0 0 0 2px rgba(79, 142, 247, 0.2);
                background: rgba(79, 142, 247, 0.1);
            }
            .player.folded {
                opacity: 0.6;
                background: rgba(239, 68, 68, 0.1);
                border-color: rgba(239, 68, 68, 0.3);
            }
            .player-name {
                font-weight: 600;
                color: var(--card);
                margin-bottom: 8px;
            }
            .player-stats {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
                font-size: 14px;
            }
            .hand {
                display: flex;
                gap: 8px;
                margin-top: 12px;
                flex-wrap: wrap;
                justify-content: center;
            }
            .card {
                width: 84px; /* 1.5x of original 56px */
                height: 120px; /* 1.5x of original 80px */
                border-radius: 8px;
                background: linear-gradient(135deg, #ffffff, #f8fafc);
                color: #1e293b;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: 700;
                font-size: 16px;
                cursor: pointer;
                transition: all 0.2s ease;
                border: 2px solid rgba(0, 0, 0, 0.1);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                position: relative;
                overflow: hidden;
            }
            .card::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(
                    135deg,
                    transparent,
                    rgba(255, 255, 255, 0.2)
                );
                pointer-events: none;
            }
            .card:hover {
                transform: translateY(-4px);
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            }
            .card.hidden {
                background: linear-gradient(135deg, #334155, #1e293b);
                color: transparent;
                cursor: default;
            }
            .card.hidden::after {
                content: "üÇ†";
                position: absolute;
                color: #64748b;
                font-size: 24px;
            }
            .card.selected {
                outline: 3px solid var(--warning);
                transform: translateY(-8px);
                box-shadow: 0 8px 16px rgba(245, 158, 11, 0.4);
            }
            .card.red {
                color: #dc2626;
            }
            .actions {
                margin-top: 12px;
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
                justify-content: center;
            }
            .status {
                font-size: 14px;
                color: var(--muted);
                margin-top: 8px;
                text-align: center;
            }
            .pot {
                font-weight: 700;
                color: var(--card);
                font-size: 18px;
            }
            .center-area {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 12px;
                text-align: center;
            }
            .table-cards {
                display: flex;
                gap: 8px;
                align-items: center;
                justify-content: center;
            }
            .chip {
                background: linear-gradient(135deg, #ffd166, #f59e0b);
                color: #1f2937;
                padding: 6px 12px;
                border-radius: 999px;
                font-weight: 700;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                font-size: 14px;
            }
            .bet-info {
                background: rgba(79, 142, 247, 0.1);
                border: 1px solid rgba(79, 142, 247, 0.3);
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 14px;
                margin: 8px 0;
                text-align: center;
            }
            .hand-strength {
                font-size: 12px;
                color: var(--success);
                font-weight: 500;
                margin-top: 4px;
            }
            input[type="number"] {
                width: 80px;
                padding: 8px;
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.2);
                background: rgba(255, 255, 255, 0.1);
                color: var(--muted);
            }
            footer {
                margin-top: 20px;
                color: rgba(255, 255, 255, 0.5);
                font-size: 13px;
                text-align: center;
                padding: 12px;
                background: rgba(255, 255, 255, 0.02);
                border-radius: 8px;
            }
            .winner-highlight {
                animation: winnerGlow 2s ease-in-out infinite alternate;
            }
            @keyframes winnerGlow {
                from {
                    box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
                }
                to {
                    box-shadow: 0 0 30px rgba(16, 185, 129, 0.8);
                }
            }
        </style>
    </head>
    <body>
        <h1>üÉè 5-Card Poker ‚Äî Offline (5-card draw)</h1>
        <div class="top">
            <div class="controls">
                <label>
                    Ch·∫ø ƒë·ªô:
                    <select id="mode">
                        <option value="solo">Solo (1 ng∆∞·ªùi vs bots)</option>
                        <option value="local">Local (pass-and-play)</option>
                    </select>
                </label>
                <label>
                    Ng∆∞·ªùi ch∆°i:
                    <select id="numPlayers">
                        <option>2</option>
                        <option>3</option>
                        <option selected>4</option>
                    </select>
                </label>
                <button id="newGame">üéÆ B·∫Øt ƒë·∫ßu v√°n m·ªõi</button>
                <button id="deal" class="secondary">üÉè Chia b√†i</button>
            </div>
            <div style="margin-left: auto">
                <span class="chip">üí∞ Pot: <span id="pot">0</span></span>
            </div>
        </div>

        <div class="table">
            <div class="panel">
                <div class="panel-title">üë• Ng∆∞·ªùi ch∆°i</div>
                <div id="players" class="players"></div>
            </div>

            <div class="panel center-area">
                <div class="panel-title">üéØ Trung t√¢m</div>
                <div class="status">
                    Tr·∫°ng th√°i: <span id="status">Ch∆∞a b·∫Øt ƒë·∫ßu</span>
                </div>
                <div class="table-cards" id="tableCards"></div>
                <div class="actions" id="globalActions"></div>
            </div>

            <div class="panel">
                <div class="panel-title">‚ö° H√†nh ƒë·ªông</div>
                <div id="actionsArea" class="actions"></div>
                <div class="status" id="infoArea"></div>
            </div>
        </div>

        <footer>üé≤ Poker: 5-card draw ‚Äî offline ‚Äî develop with AI.</footer>

        <script>
            /* ====== GAME CORE ====== */
            const SUITS = ["‚ô†", "‚ô•", "‚ô¶", "‚ô£"];
            const RANKS = [
                { r: "2", v: 2 },
                { r: "3", v: 3 },
                { r: "4", v: 4 },
                { r: "5", v: 5 },
                { r: "6", v: 6 },
                { r: "7", v: 7 },
                { r: "8", v: 8 },
                { r: "9", v: 9 },
                { r: "10", v: 10 },
                { r: "J", v: 11 },
                { r: "Q", v: 12 },
                { r: "K", v: 13 },
                { r: "A", v: 14 },
            ];

            function createDeck() {
                const d = [];
                for (const s of SUITS)
                    for (const rk of RANKS)
                        d.push({ suit: s, rank: rk.r, value: rk.v });
                return d;
            }

            function shuffle(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                return deck;
            }

            /* ====== Hand evaluator (5-card poker) ====== */
            function evaluateHand(cards) {
                const vals = cards.map((c) => c.value).sort((a, b) => a - b);
                const suits = cards.map((c) => c.suit);
                const counts = {};
                for (const v of vals) counts[v] = (counts[v] || 0) + 1;

                const freqPairs = Object.entries(counts).map(([v, c]) => ({
                    v: +v,
                    c,
                }));
                freqPairs.sort((a, b) => b.c - a.c || b.v - a.v);

                const isFlush = suits.every((s) => s === suits[0]);
                let isStraight = false;
                const uniqVals = [...new Set(vals)];
                if (uniqVals.length === 5) {
                    const max = uniqVals[4],
                        min = uniqVals[0];
                    if (max - min === 4) isStraight = true;
                    else if (
                        JSON.stringify(uniqVals) ===
                        JSON.stringify([2, 3, 4, 5, 14])
                    )
                        isStraight = true;
                }

                if (isStraight && isFlush)
                    return {
                        rank: 8,
                        tiebreak: [
                            Math.max(...vals) === 14 && vals.includes(2)
                                ? 5
                                : Math.max(...vals),
                        ],
                        name: "Straight Flush",
                    };
                if (freqPairs[0].c === 4)
                    return {
                        rank: 7,
                        tiebreak: [freqPairs[0].v, freqPairs[1].v],
                        name: "Four of a Kind",
                    };
                if (
                    freqPairs[0].c === 3 &&
                    freqPairs[1] &&
                    freqPairs[1].c === 2
                )
                    return {
                        rank: 6,
                        tiebreak: [freqPairs[0].v, freqPairs[1].v],
                        name: "Full House",
                    };
                if (isFlush)
                    return {
                        rank: 5,
                        tiebreak: vals.slice().sort((a, b) => b - a),
                        name: "Flush",
                    };
                if (isStraight)
                    return {
                        rank: 4,
                        tiebreak: [
                            Math.max(...vals) === 14 && vals.includes(2)
                                ? 5
                                : Math.max(...vals),
                        ],
                        name: "Straight",
                    };
                if (freqPairs[0].c === 3) {
                    const kickers = freqPairs
                        .slice(1)
                        .map((x) => x.v)
                        .sort((a, b) => b - a);
                    return {
                        rank: 3,
                        tiebreak: [freqPairs[0].v, ...kickers],
                        name: "Three of a Kind",
                    };
                }
                if (
                    freqPairs[0].c === 2 &&
                    freqPairs[1] &&
                    freqPairs[1].c === 2
                ) {
                    const pairHigh = Math.max(freqPairs[0].v, freqPairs[1].v);
                    const pairLow = Math.min(freqPairs[0].v, freqPairs[1].v);
                    const kicker = freqPairs.slice(2).map((x) => x.v)[0];
                    return {
                        rank: 2,
                        tiebreak: [pairHigh, pairLow, kicker],
                        name: "Two Pair",
                    };
                }
                if (freqPairs[0].c === 2) {
                    const kickers = freqPairs
                        .slice(1)
                        .map((x) => x.v)
                        .sort((a, b) => b - a);
                    return {
                        rank: 1,
                        tiebreak: [freqPairs[0].v, ...kickers],
                        name: "One Pair",
                    };
                }
                return {
                    rank: 0,
                    tiebreak: vals.slice().sort((a, b) => b - a),
                    name: "High Card",
                };
            }

            function compareHands(hA, hB) {
                if (hA.rank !== hB.rank) return hA.rank > hB.rank ? 1 : -1;
                for (
                    let i = 0;
                    i < Math.max(hA.tiebreak.length, hB.tiebreak.length);
                    i++
                ) {
                    const a = hA.tiebreak[i] || 0,
                        b = hB.tiebreak[i] || 0;
                    if (a !== b) return a > b ? 1 : -1;
                }
                return 0;
            }

            /* ====== IMPROVED BOT AI ====== */
            function calculateHandStrength(hand) {
                const eval = evaluateHand(hand);
                // Return strength score 0-100
                const baseStrength = {
                    8: 95, // Straight Flush
                    7: 90, // Four of a Kind
                    6: 85, // Full House
                    5: 75, // Flush
                    4: 70, // Straight
                    3: 60, // Three of a Kind
                    2: 45, // Two Pair
                    1: 25, // One Pair
                    0: 10, // High Card
                };

                let strength = baseStrength[eval.rank] || 10;

                // Adjust based on high cards for weak hands
                if (eval.rank <= 1) {
                    const highCard = Math.max(...hand.map((c) => c.value));
                    if (highCard >= 12) strength += 5; // Face cards
                    if (highCard === 14) strength += 5; // Ace
                }

                // Adjust pair strength
                if (eval.rank === 1) {
                    const pairValue = eval.tiebreak[0];
                    if (pairValue >= 11) strength += 10; // High pairs
                    if (pairValue >= 13) strength += 5; // Very high pairs
                }

                return Math.min(100, strength);
            }

            function calculatePotOdds(callAmount, potSize) {
                if (callAmount === 0) return Infinity;
                return potSize / callAmount;
            }

            function shouldBluff(position, handStrength, potSize) {
                // More aggressive bluffing in late position with reasonable pot
                if (position === "late" && handStrength < 30 && potSize > 50) {
                    return Math.random() < 0.15; // 15% chance to bluff
                }
                if (position === "early" && handStrength < 20) {
                    return Math.random() < 0.05; // 5% chance to bluff early
                }
                return false;
            }

            function getBotDecision(bot, gameState) {
                const handStrength = calculateHandStrength(bot.hand);
                const callAmount = Math.max(
                    0,
                    gameState.currentBet - bot.betThisRound,
                );
                const potOdds = calculatePotOdds(callAmount, gameState.pot);
                const chipRatio = bot.chips / 500; // Starting chips ratio

                // Determine position (early/middle/late)
                const totalPlayers = gameState.players.filter(
                    (p) => !p.folded && p.chips > 0,
                ).length;
                const position =
                    gameState.currentPlayerIdx < totalPlayers / 3
                        ? "early"
                        : gameState.currentPlayerIdx > (2 * totalPlayers) / 3
                          ? "late"
                          : "middle";

                // Personality traits based on bot ID
                const personality = getBotPersonality(bot.id);

                let decision = { action: "fold", amount: 0 };

                // Apply personality modifiers
                let adjustedStrength = handStrength;
                adjustedStrength += personality.aggression * 10;
                adjustedStrength += personality.bluffiness * 5;

                if (callAmount === 0) {
                    // Free to check
                    if (
                        adjustedStrength > 40 ||
                        shouldBluff(position, handStrength, gameState.pot)
                    ) {
                        // Consider betting
                        if (
                            adjustedStrength > 60 &&
                            Math.random() < personality.aggression
                        ) {
                            decision = {
                                action: "raise",
                                amount: gameState.minBet,
                            };
                        } else {
                            decision = { action: "check", amount: 0 };
                        }
                    } else {
                        decision = { action: "check", amount: 0 };
                    }
                } else {
                    // Need to call or fold
                    const callThreshold =
                        30 + personality.tightness * 20 - chipRatio * 10;

                    if (
                        adjustedStrength > callThreshold + 20 &&
                        chipRatio > 0.3
                    ) {
                        // Strong hand, consider raising
                        if (
                            Math.random() < personality.aggression &&
                            adjustedStrength > 70
                        ) {
                            decision = {
                                action: "raise",
                                amount: Math.min(
                                    bot.chips,
                                    callAmount + gameState.minBet,
                                ),
                            };
                        } else {
                            decision = {
                                action: "call",
                                amount: Math.min(callAmount, bot.chips),
                            };
                        }
                    } else if (
                        adjustedStrength > callThreshold ||
                        potOdds > 3
                    ) {
                        // Marginal hand but good pot odds
                        decision = {
                            action: "call",
                            amount: Math.min(callAmount, bot.chips),
                        };
                    } else if (
                        shouldBluff(position, handStrength, gameState.pot) &&
                        chipRatio > 0.5
                    ) {
                        // Bluff attempt
                        decision = {
                            action: "raise",
                            amount: Math.min(
                                bot.chips,
                                callAmount + gameState.minBet,
                            ),
                        };
                    } else {
                        decision = { action: "fold", amount: 0 };
                    }
                }

                return decision;
            }

            function getBotPersonality(botId) {
                const personalities = [
                    { aggression: 0.3, tightness: 0.7, bluffiness: 0.2 }, // Conservative
                    { aggression: 0.8, tightness: 0.2, bluffiness: 0.6 }, // Aggressive
                    { aggression: 0.5, tightness: 0.5, bluffiness: 0.3 }, // Balanced
                    { aggression: 0.2, tightness: 0.8, bluffiness: 0.1 }, // Very tight
                ];
                return personalities[botId % personalities.length];
            }

            function getBotDrawStrategy(bot) {
                const handEval = evaluateHand(bot.hand);
                const handStrength = calculateHandStrength(bot.hand);

                // Keep strong hands
                if (handStrength >= 60) {
                    return []; // Keep all cards
                }

                // Analyze for draws
                const suits = {};
                const values = {};
                bot.hand.forEach((card) => {
                    suits[card.suit] = (suits[card.suit] || 0) + 1;
                    values[card.value] = (values[card.value] || 0) + 1;
                });

                // Check for flush draw
                const flushSuit = Object.entries(suits).find(
                    ([suit, count]) => count === 4,
                );
                if (flushSuit) {
                    // Keep 4 cards of same suit, discard the odd one
                    return bot.hand.filter(
                        (card) => card.suit !== flushSuit[0],
                    );
                }

                // Check for straight draw
                const sortedValues = bot.hand
                    .map((c) => c.value)
                    .sort((a, b) => a - b);
                const gaps = [];
                for (let i = 1; i < sortedValues.length; i++) {
                    gaps.push(sortedValues[i] - sortedValues[i - 1]);
                }

                // Open-ended straight draw
                if (gaps.filter((g) => g === 1).length >= 3) {
                    // Keep cards that form the sequence
                    const sequence = [sortedValues[0]];
                    for (let i = 1; i < sortedValues.length; i++) {
                        if (
                            sortedValues[i] - sequence[sequence.length - 1] <=
                            2
                        ) {
                            sequence.push(sortedValues[i]);
                        }
                    }
                    if (sequence.length >= 4) {
                        return bot.hand.filter(
                            (card) => !sequence.includes(card.value),
                        );
                    }
                }

                // Keep pairs and higher
                const pairs = Object.entries(values).filter(
                    ([val, count]) => count >= 2,
                );
                if (pairs.length > 0) {
                    const keepValues = pairs.map(([val, count]) =>
                        parseInt(val),
                    );
                    return bot.hand.filter(
                        (card) => !keepValues.includes(card.value),
                    );
                }

                // Keep high cards (J or better)
                const highCards = bot.hand.filter((card) => card.value >= 11);
                if (highCards.length >= 2) {
                    const keepCards = highCards.slice(0, 2);
                    return bot.hand.filter((card) => !keepCards.includes(card));
                }

                // Default: keep highest card, discard others
                const highest = bot.hand.reduce((max, card) =>
                    card.value > max.value ? card : max,
                );
                return bot.hand.filter((card) => card !== highest);
            }

            /* ====== GAME STATE ====== */
            let G = {
                deck: [],
                players: [],
                pot: 0,
                currentPlayerIdx: 0,
                dealerIdx: 0,
                stage: "idle",
                minBet: 10,
                currentBet: 0,
                numPlayers: 4,
            };

            const ui = {
                playersEl: document.getElementById("players"),
                status: document.getElementById("status"),
                pot: document.getElementById("pot"),
                actionsArea: document.getElementById("actionsArea"),
                infoArea: document.getElementById("infoArea"),
                dealBtn: document.getElementById("deal"),
                newGameBtn: document.getElementById("newGame"),
                modeSel: document.getElementById("mode"),
                numPlayersSel: document.getElementById("numPlayers"),
            };

            function resetGame() {
                G.deck = shuffle(createDeck());
                G.pot = 0;
                G.players = [];
                G.currentBet = 0;
                G.stage = "idle";
                G.dealerIdx = 0;
                ui.infoArea.textContent = "";
                ui.status.textContent = "Ch∆∞a b·∫Øt ƒë·∫ßu";
                ui.pot.textContent = G.pot;
            }

            function startNewRound() {
                G.deck = shuffle(createDeck());
                for (const p of G.players) {
                    p.hand = [];
                    p.active = p.chips > 0;
                    p.betThisRound = 0;
                    p.folded = false;
                }
                G.pot = 0;
                G.currentBet = G.minBet;
                G.stage = "pre";

                // Deal 5 cards each
                for (let i = 0; i < 5; i++) {
                    for (let pi = 0; pi < G.players.length; pi++) {
                        if (G.players[pi].chips > 0) {
                            G.players[pi].hand.push(G.deck.pop());
                        }
                    }
                }

                G.currentPlayerIdx = (G.dealerIdx + 1) % G.players.length;
                ui.status.textContent = "V√≤ng c∆∞·ª£c 1 (pre-draw)";
                ui.pot.textContent = G.pot;
                render();
                proceedTurn();
            }

            function initPlayers(num, mode) {
                G.players = [];
                const botNames = [
                    "ü§ñ Alpha",
                    "ü§ñ Beta",
                    "ü§ñ Gamma",
                    "ü§ñ Delta",
                ];
                for (let i = 0; i < num; i++) {
                    const isBot =
                        (mode === "solo" && i > 0) ||
                        (mode === "local" ? false : i > 0);
                    G.players.push({
                        id: i,
                        name: isBot
                            ? botNames[i - 1] || `ü§ñ Bot ${i}`
                            : `üë§ Ng∆∞·ªùi ${i + 1}`,
                        isBot,
                        hand: [],
                        chips: 500,
                        active: true,
                        folded: false,
                        betThisRound: 0,
                    });
                }
            }

            /* ====== UI RENDER ====== */
            function render() {
                ui.playersEl.innerHTML = "";
                G.players.forEach((p, idx) => {
                    const div = document.createElement("div");
                    div.className = "player";
                    if (idx === G.currentPlayerIdx) div.className += " active";
                    if (p.folded) div.className += " folded";

                    const handStrength =
                        p.hand.length === 5 ? calculateHandStrength(p.hand) : 0;
                    const handEval =
                        p.hand.length === 5
                            ? evaluateHand(p.hand)
                            : { name: "Incomplete" };

                    div.innerHTML = `
                        <div class="player-name">${p.name}</div>
                        <div class="player-stats">
                            <span class="chip">${p.chips}</span>
                            ${p.betThisRound > 0 ? `<span style="color: var(--warning)">Bet: ${p.betThisRound}</span>` : ""}
                        </div>
                        ${p.folded ? '<div style="color: var(--danger); font-weight: bold;">‚ùå FOLDED</div>' : ""}
                        ${!p.isBot && p.hand.length === 5 ? `<div class="hand-strength">${handEval.name} (${Math.round(handStrength)}%)</div>` : ""}
                        <div class="hand" id="hand-${idx}"></div>
                    `;

                    ui.playersEl.appendChild(div);
                    const handEl = div.querySelector(`#hand-${idx}`);

                    p.hand.forEach((c, i) => {
                        const cdiv = document.createElement("div");
                        const isRed = c.suit === "‚ô•" || c.suit === "‚ô¶";
                        cdiv.className = "card" + (isRed ? " red" : "");

                        // Show cards for human players or in showdown
                        const showCard =
                            !p.isBot ||
                            G.stage === "showdown" ||
                            idx === getHumanIndex();

                        if (showCard) {
                            cdiv.textContent = c.rank + c.suit;
                            if (idx === getHumanIndex() && G.stage === "draw") {
                                cdiv.addEventListener("click", () => {
                                    cdiv.classList.toggle("selected");
                                    c.selected =
                                        cdiv.classList.contains("selected");
                                });
                            }
                        } else {
                            cdiv.className += " hidden";
                        }

                        handEl.appendChild(cdiv);
                    });
                });

                ui.pot.textContent = G.pot;
                ui.status.textContent =
                    {
                        idle: "Ch∆∞a b·∫Øt ƒë·∫ßu",
                        pre: "V√≤ng c∆∞·ª£c 1 (pre-draw)",
                        draw: "V√≤ng r√∫t b√†i",
                        post: "V√≤ng c∆∞·ª£c 2 (post-draw)",
                        showdown: "Showdown",
                    }[G.stage] || G.stage;
            }

            /* ====== Turn logic ====== */
            function getHumanIndex() {
                return G.players.findIndex((p) => !p.isBot);
            }

            function proceedTurn() {
                if (G.stage === "pre" || G.stage === "post") {
                    let loops = 0;
                    while (
                        G.players[G.currentPlayerIdx].folded ||
                        G.players[G.currentPlayerIdx].chips <= 0
                    ) {
                        G.currentPlayerIdx =
                            (G.currentPlayerIdx + 1) % G.players.length;
                        if (++loops > 20) break;
                    }

                    const p = G.players[G.currentPlayerIdx];
                    if (p.isBot) {
                        setTimeout(() => improvedBotAct(p), 800);
                        return;
                    } else {
                        showActionsForHuman(p);
                    }
                } else if (G.stage === "draw") {
                    handleDrawPhase();
                }
            }

            function showActionsForHuman(p) {
                ui.actionsArea.innerHTML = "";
                const callAmt = Math.max(0, G.currentBet - p.betThisRound);

                // Call/Check button
                const btnCheck = document.createElement("button");
                btnCheck.textContent =
                    callAmt === 0 ? "‚úÖ Check" : `üìû Call ${callAmt}`;
                btnCheck.onclick = () => {
                    if (callAmt > 0) {
                        const pay = Math.min(callAmt, p.chips);
                        p.chips -= pay;
                        p.betThisRound += pay;
                        G.pot += pay;
                    }
                    nextPlayer();
                };
                ui.actionsArea.appendChild(btnCheck);

                // Fold button
                const btnFold = document.createElement("button");
                btnFold.className = "secondary";
                btnFold.textContent = "‚ùå Fold";
                btnFold.onclick = () => {
                    p.folded = true;
                    nextPlayer();
                };
                ui.actionsArea.appendChild(btnFold);

                // Raise button
                if (p.chips > callAmt) {
                    const btnRaise = document.createElement("button");
                    btnRaise.textContent = `‚¨ÜÔ∏è Raise ${G.minBet}`;
                    btnRaise.style.background = "var(--warning)";
                    btnRaise.onclick = () => {
                        const raiseAmt = Math.min(p.chips, callAmt + G.minBet);
                        p.chips -= raiseAmt;
                        p.betThisRound += raiseAmt;
                        G.currentBet = p.betThisRound;
                        G.pot += raiseAmt;
                        nextPlayer();
                    };
                    ui.actionsArea.appendChild(btnRaise);
                }

                ui.infoArea.innerHTML = `<div class="bet-info">üí∞ C·∫ßn call: ${callAmt} | üéØ Pot: ${G.pot}</div>`;
            }

            function nextPlayer() {
                G.currentPlayerIdx =
                    (G.currentPlayerIdx + 1) % G.players.length;
                ui.actionsArea.innerHTML = "";
                render();
                if (isBettingRoundComplete()) {
                    advanceStageAfterBet();
                } else {
                    proceedTurn();
                }
            }

            function improvedBotAct(p) {
                const decision = getBotDecision(p, G);
                const callAmt = Math.max(0, G.currentBet - p.betThisRound);

                // Show bot thinking
                ui.infoArea.textContent = `${p.name} ƒëang suy nghƒ©...`;

                setTimeout(() => {
                    switch (decision.action) {
                        case "fold":
                            p.folded = true;
                            ui.infoArea.textContent = `${p.name} fold.`;
                            break;
                        case "check":
                            ui.infoArea.textContent = `${p.name} check.`;
                            break;
                        case "call":
                            const payCall = Math.min(decision.amount, p.chips);
                            p.chips -= payCall;
                            p.betThisRound += payCall;
                            G.pot += payCall;
                            ui.infoArea.textContent = `${p.name} call ${payCall}.`;
                            break;
                        case "raise":
                            const payRaise = Math.min(decision.amount, p.chips);
                            p.chips -= payRaise;
                            p.betThisRound += payRaise;
                            G.currentBet = Math.max(
                                G.currentBet,
                                p.betThisRound,
                            );
                            G.pot += payRaise;
                            ui.infoArea.textContent = `${p.name} raise to ${p.betThisRound}!`;
                            break;
                    }

                    nextPlayer();
                }, 500);
            }

            function isBettingRoundComplete() {
                for (const p of G.players) {
                    if (p.folded || p.chips <= 0) continue;
                    if (p.betThisRound !== G.currentBet) return false;
                }
                return true;
            }

            function advanceStageAfterBet() {
                for (const p of G.players) p.betThisRound = 0;

                if (G.stage === "pre") {
                    G.stage = "draw";
                    ui.status.textContent = "V√≤ng r√∫t b√†i";
                    G.currentPlayerIdx = (G.dealerIdx + 1) % G.players.length;
                    render();
                    proceedTurn();
                } else if (G.stage === "post") {
                    G.stage = "showdown";
                    ui.status.textContent = "Showdown";
                    render();
                    doShowdown();
                }
            }

            function handleDrawPhase() {
                const p = G.players[G.currentPlayerIdx];

                if (p.folded || p.chips <= 0) {
                    G.currentPlayerIdx =
                        (G.currentPlayerIdx + 1) % G.players.length;
                    if (
                        G.currentPlayerIdx ===
                        (G.dealerIdx + 1) % G.players.length
                    ) {
                        startPostDrawBetting();
                        return;
                    } else {
                        handleDrawPhase();
                        return;
                    }
                }

                if (p.isBot) {
                    ui.infoArea.textContent = `${p.name} ƒëang r√∫t b√†i...`;
                    setTimeout(() => {
                        const toReplace = getBotDrawStrategy(p);
                        const replaceCount = Math.min(toReplace.length, 3);

                        for (let i = 0; i < replaceCount; i++) {
                            const idx = p.hand.indexOf(toReplace[i]);
                            if (idx >= 0 && G.deck.length > 0) {
                                p.hand[idx] = G.deck.pop();
                            }
                        }

                        ui.infoArea.textContent = `${p.name} r√∫t ${replaceCount} l√°.`;

                        G.currentPlayerIdx =
                            (G.currentPlayerIdx + 1) % G.players.length;
                        if (
                            G.currentPlayerIdx ===
                            (G.dealerIdx + 1) % G.players.length
                        ) {
                            setTimeout(startPostDrawBetting, 1000);
                        } else {
                            setTimeout(() => {
                                handleDrawPhase();
                                render();
                            }, 800);
                        }
                    }, 600);
                } else {
                    // Human draw interface
                    ui.actionsArea.innerHTML = "";

                    const drawBtn = document.createElement("button");
                    drawBtn.textContent = "üé¥ R√∫t l√° ƒë√£ ch·ªçn (t·ªëi ƒëa 3)";
                    drawBtn.onclick = () => {
                        const sel = p.hand.filter((c) => c.selected);
                        if (sel.length > 3) {
                            ui.infoArea.textContent =
                                "‚ùå Kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 3 l√°!";
                            return;
                        }

                        for (const r of sel) {
                            const idx = p.hand.indexOf(r);
                            if (idx >= 0 && G.deck.length > 0) {
                                p.hand[idx] = G.deck.pop();
                            }
                        }

                        p.hand.forEach((c) => delete c.selected);
                        ui.infoArea.textContent = `B·∫°n ƒë√£ r√∫t ${sel.length} l√°.`;

                        G.currentPlayerIdx =
                            (G.currentPlayerIdx + 1) % G.players.length;
                        ui.actionsArea.innerHTML = "";
                        render();

                        if (
                            G.currentPlayerIdx ===
                            (G.dealerIdx + 1) % G.players.length
                        ) {
                            setTimeout(startPostDrawBetting, 1000);
                        } else {
                            handleDrawPhase();
                        }
                    };
                    ui.actionsArea.appendChild(drawBtn);

                    const skipBtn = document.createElement("button");
                    skipBtn.className = "secondary";
                    skipBtn.textContent = "‚è≠Ô∏è Kh√¥ng r√∫t";
                    skipBtn.onclick = () => {
                        p.hand.forEach((c) => delete c.selected);
                        G.currentPlayerIdx =
                            (G.currentPlayerIdx + 1) % G.players.length;
                        ui.actionsArea.innerHTML = "";
                        render();

                        if (
                            G.currentPlayerIdx ===
                            (G.dealerIdx + 1) % G.players.length
                        ) {
                            setTimeout(startPostDrawBetting, 1000);
                        } else {
                            handleDrawPhase();
                        }
                    };
                    ui.actionsArea.appendChild(skipBtn);

                    ui.infoArea.innerHTML = `<div class="bet-info">üéØ Ch·ªçn t·ªëi ƒëa 3 l√° ƒë·ªÉ r√∫t (click v√†o l√° b√†i ƒë·ªÉ ch·ªçn)</div>`;
                    render();
                }
            }

            function startPostDrawBetting() {
                G.stage = "post";
                G.currentBet = G.minBet;
                G.currentPlayerIdx = (G.dealerIdx + 1) % G.players.length;
                ui.status.textContent = "V√≤ng c∆∞·ª£c 2 (post-draw)";
                render();
                proceedTurn();
            }

            function doShowdown() {
                const contenders = G.players.filter(
                    (p) => !p.folded && p.hand.length === 5,
                );

                if (contenders.length === 0) {
                    ui.infoArea.textContent =
                        "üö´ Kh√¥ng c√≤n ng∆∞·ªùi ch∆°i: pot gi·ªØ l·∫°i.";
                    return;
                }

                const evals = contenders.map((p) => ({
                    p,
                    eval: evaluateHand(p.hand),
                }));

                // Find winner(s)
                let winners = [evals[0]];
                for (let i = 1; i < evals.length; i++) {
                    const cmp = compareHands(evals[i].eval, winners[0].eval);
                    if (cmp > 0) {
                        winners = [evals[i]];
                    } else if (cmp === 0) {
                        winners.push(evals[i]);
                    }
                }

                // Award pot
                const share = Math.floor(G.pot / winners.length);
                winners.forEach((w) => {
                    w.p.chips += share;
                    // Add winner highlight
                    const playerEl = document.querySelector(
                        `.player:nth-child(${G.players.indexOf(w.p) + 1})`,
                    );
                    if (playerEl) playerEl.classList.add("winner-highlight");
                });

                const winnerNames = winners.map((w) => w.p.name).join(", ");
                const handName = winners[0].eval.name;

                ui.infoArea.innerHTML = `
                    <div class="bet-info" style="background: rgba(16, 185, 129, 0.2); border-color: var(--success);">
                        üèÜ <strong>${winnerNames}</strong> th·∫Øng v·ªõi <strong>${handName}</strong>!<br>
                        üí∞ M·ªói ng∆∞·ªùi nh·∫≠n: ${share} chips
                    </div>
                `;

                G.pot = 0;
                ui.pot.textContent = "0";
                render();

                // Prepare next round
                setTimeout(() => {
                    // Remove winner highlight
                    document
                        .querySelectorAll(".winner-highlight")
                        .forEach((el) => {
                            el.classList.remove("winner-highlight");
                        });

                    G.dealerIdx = (G.dealerIdx + 1) % G.players.length;
                    G.stage = "idle";
                    ui.infoArea.textContent =
                        'üé≤ Nh·∫•n "Chia b√†i" ƒë·ªÉ ch∆°i v√°n ti·∫øp theo.';
                }, 4000);
            }

            /* ====== Buttons ====== */
            ui.newGameBtn.onclick = () => {
                const mode = ui.modeSel.value;
                const num = parseInt(ui.numPlayersSel.value);
                G.numPlayers = num;
                resetGame();
                initPlayers(num, mode);
                ui.infoArea.textContent =
                    'üéÆ Game created! Nh·∫•n "Chia b√†i" ƒë·ªÉ b·∫Øt ƒë·∫ßu v√°n.';
                render();
            };

            ui.dealBtn.onclick = () => {
                if (G.players.length === 0) {
                    ui.infoArea.textContent =
                        '‚ö†Ô∏è Nh·∫•n "B·∫Øt ƒë·∫ßu v√°n m·ªõi" tr∆∞·ªõc!';
                    return;
                }
                startNewRound();
            };

            /* ====== Initialize ====== */
            resetGame();
            initPlayers(4, "solo");
            render();
            ui.infoArea.textContent =
                'üéØ Ch·ªçn s·ªë ng∆∞·ªùi v√† nh·∫•n "B·∫Øt ƒë·∫ßu v√°n m·ªõi" r·ªìi "Chia b√†i" ƒë·ªÉ ch∆°i!';
        </script>
    </body>
</html>
